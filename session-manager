#!/bin/bash
# session-manager - Launch AgentDeck on remote systems via SSH

set -e

VERSION="2.2.0"

# =============================================================================
# CONFIGURATION - Load config file if exists
# =============================================================================

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/session-manager"
CONFIG_FILE="$CONFIG_DIR/config"

# Source config file first so exported variables are available for defaults
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

SSH_CONFIG="${SESSION_MANAGER_SSH_CONFIG:-$HOME/.ssh/config}"
REMOTE_CMD="${SESSION_MANAGER_REMOTE_CMD:-bash}"
REMOTE_DIR="${SESSION_MANAGER_REMOTE_DIR:-~}"

# =============================================================================
# SSH HOST REGISTRY (bash 3.2 compatible - using indexed arrays)
# =============================================================================

# Parallel arrays for host data
SSH_HOST_NAMES=()      # Host alias names
SSH_HOST_HOSTNAMES=()  # Actual hostnames/IPs
SSH_HOST_USERS=()      # Users for each host
SSH_HOST_PORTS=()      # Ports for each host

# =============================================================================
# LOCAL APP REGISTRY (bash 3.2 compatible - using indexed arrays)
# =============================================================================

LOCAL_APP_NAMES=()      # App names
LOCAL_APP_CMDS=()       # Commands to run
LOCAL_APP_DESCS=()      # Descriptions
LOCAL_APP_ENVS=()       # Environment variables

# Register a local app
register_local_app() {
    local app="$1"
    local cmd="$2"
    local desc="$3"
    local envs="${4:-}"

    LOCAL_APP_NAMES+=("$app")
    LOCAL_APP_CMDS+=("$cmd")
    LOCAL_APP_DESCS+=("$desc")
    LOCAL_APP_ENVS+=("$envs")
}

# Get index for app name (-1 if not found)
get_local_app_index() {
    local app="$1"
    local i=0
    for a in "${LOCAL_APP_NAMES[@]}"; do
        if [ "$a" = "$app" ]; then
            echo "$i"
            return 0
        fi
        i=$((i + 1))
    done
    echo "-1"
    return 1
}

# Check if local app exists
local_app_exists() {
    local idx=$(get_local_app_index "$1")
    [ "$idx" != "-1" ]
}

# Get app command
get_local_app_cmd() {
    local idx=$(get_local_app_index "$1")
    if [ "$idx" != "-1" ]; then
        echo "${LOCAL_APP_CMDS[$idx]}"
    fi
}

# Get app description
get_local_app_desc() {
    local idx=$(get_local_app_index "$1")
    if [ "$idx" != "-1" ]; then
        echo "${LOCAL_APP_DESCS[$idx]}"
    fi
}

# Get app environment variables
get_local_app_env() {
    local idx=$(get_local_app_index "$1")
    if [ "$idx" != "-1" ]; then
        echo "${LOCAL_APP_ENVS[$idx]}"
    fi
}

# =============================================================================
# BUILT-IN LOCAL APPS
# =============================================================================

# Interactive bash shell
register_local_app "bash" "bash --login" \
    "Interactive bash shell" \
    ""

# OpenCode editor (terminal TUI)
register_local_app "opencode" "opencode" \
    "OpenCode editor TUI" \
    ""

# Claude Code CLI
register_local_app "claude" "claude --dangerously-skip-permissions" \
    "Claude Code CLI" \
    "COLORTERM=truecolor"

# =============================================================================
# SSH CONFIG PARSER
# =============================================================================

# Get index for a host name (-1 if not found)
get_host_index() {
    local host="$1"
    local i=0
    for h in "${SSH_HOST_NAMES[@]}"; do
        if [ "$h" = "$host" ]; then
            echo "$i"
            return 0
        fi
        i=$((i + 1))
    done
    echo "-1"
    return 1
}

# Check if host exists
host_exists() {
    local idx=$(get_host_index "$1")
    [ "$idx" != "-1" ]
}

# Get hostname for a host
get_hostname() {
    local idx=$(get_host_index "$1")
    if [ "$idx" != "-1" ]; then
        echo "${SSH_HOST_HOSTNAMES[$idx]}"
    else
        echo "$1"
    fi
}

# Get user for a host
get_user() {
    local idx=$(get_host_index "$1")
    if [ "$idx" != "-1" ]; then
        echo "${SSH_HOST_USERS[$idx]}"
    fi
}

# Get port for a host
get_port() {
    local idx=$(get_host_index "$1")
    if [ "$idx" != "-1" ]; then
        echo "${SSH_HOST_PORTS[$idx]}"
    fi
}

# Parse SSH config file and populate host registry
parse_ssh_config() {
    local config_file="${1:-$SSH_CONFIG}"

    if [ ! -f "$config_file" ]; then
        return 1
    fi

    local current_host=""
    local current_idx=-1
    local line

    while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        case "$line" in
            \#*|"") continue ;;
        esac

        # Trim leading whitespace
        line="${line#"${line%%[![:space:]]*}"}"

        # Parse Host directive (case insensitive)
        if echo "$line" | grep -qi "^host[[:space:]]"; then
            current_host=$(echo "$line" | sed 's/^[Hh]ost[[:space:]]*//')
            # Skip wildcard entries
            case "$current_host" in
                *\**|*\?*) current_host=""; continue ;;
            esac
            # Add new host
            current_idx=${#SSH_HOST_NAMES[@]}
            SSH_HOST_NAMES+=("$current_host")
            SSH_HOST_HOSTNAMES+=("$current_host")  # Default to alias
            SSH_HOST_USERS+=("")
            SSH_HOST_PORTS+=("")
            continue
        fi

        # Skip if no current host
        [ -z "$current_host" ] && continue

        # Parse HostName
        if echo "$line" | grep -qi "^hostname[[:space:]]"; then
            SSH_HOST_HOSTNAMES[$current_idx]=$(echo "$line" | sed 's/^[Hh]ost[Nn]ame[[:space:]]*//')
            continue
        fi

        # Parse User
        if echo "$line" | grep -qi "^user[[:space:]]"; then
            SSH_HOST_USERS[$current_idx]=$(echo "$line" | sed 's/^[Uu]ser[[:space:]]*//')
            continue
        fi

        # Parse Port
        if echo "$line" | grep -qi "^port[[:space:]]"; then
            SSH_HOST_PORTS[$current_idx]=$(echo "$line" | sed 's/^[Pp]ort[[:space:]]*//')
            continue
        fi
    done < "$config_file"
}

# Get formatted host display string
get_host_display() {
    local host="$1"
    local hostname=$(get_hostname "$host")
    local user=$(get_user "$host")
    local port=$(get_port "$host")

    local display=""
    if [ -n "$user" ]; then
        display="${user}@${hostname}"
    else
        display="$hostname"
    fi

    if [ -n "$port" ] && [ "$port" != "22" ]; then
        display="${display}:${port}"
    fi

    echo "$display"
}

# List all SSH hosts from config
list_ssh_hosts() {
    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Available SSH Hosts${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    if [ ${#SSH_HOST_NAMES[@]} -eq 0 ]; then
        print_warning "No hosts found in SSH config"
        print_info "SSH config: $SSH_CONFIG"
        return 1
    fi

    local i=1
    for host in "${SSH_HOST_NAMES[@]}"; do
        local display=$(get_host_display "$host")
        printf "  ${CYAN}[%2d]${NC} %-20s %s\n" "$i" "$host" "($display)"
        i=$((i + 1))
    done
    echo ""
}

# Test SSH connection to a host
test_ssh_connection() {
    local host="$1"
    print_info "Testing connection to $host..."

    if ssh -o ConnectTimeout=5 -o BatchMode=yes "$host" "echo 'Connection successful'" 2>/dev/null; then
        print_success "Connection to $host successful"
        return 0
    else
        print_error "Failed to connect to $host"
        return 1
    fi
}

# Check if agent-deck is installed on remote
check_remote_cmd() {
    local host="$1"
    local cmd="${2:-$REMOTE_CMD}"

    # Use login shell to ensure PATH includes user directories like ~/.local/bin
    if ssh -o ConnectTimeout=5 "$host" "bash -l -c 'command -v $cmd'" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# =============================================================================
# LOCAL SESSION MANAGEMENT
# =============================================================================

# Create local session for an app
create_local_session() {
    local app="$1"
    local session_name="$2"
    local work_dir="${3:-$PWD}"

    if ! local_app_exists "$app"; then
        print_error "Unknown local app: $app"
        print_info "Use 'sm local-apps' to see available apps."
        return 1
    fi

    local cmd=$(get_local_app_cmd "$app")
    local envs=$(get_local_app_env "$app")
    local desc=$(get_local_app_desc "$app")

    print_info "Creating local session '$session_name'"
    print_info "App: $app - $desc"
    print_info "Directory: $work_dir"

    if tmux has-session -t "$session_name" 2>/dev/null; then
        print_warning "Session '$session_name' already exists, attaching..."
        attach_session "$session_name"
        return 0
    fi

    if [ ! -d "$work_dir" ]; then
        print_error "Directory does not exist: $work_dir"
        return 1
    fi

    local full_cmd=""
    if [ -n "$envs" ]; then
        full_cmd="export $envs && exec $cmd"
    else
        full_cmd="exec $cmd"
    fi

    tmux new-session -d -s "$session_name" -c "$work_dir" bash -c "$full_cmd"
    print_success "Created local session '$session_name'"
    print_info "Detach: Ctrl+B, D"
}

# Interactive local session creation
create_local_session_interactive() {
    echo ""
    print_info "Create Local Session"
    echo ""

    if [ ${#LOCAL_APP_NAMES[@]} -eq 0 ]; then
        print_warning "No local apps configured"
        return 1
    fi

    echo "Available apps:"
    local i=1
    for app in "${LOCAL_APP_NAMES[@]}"; do
        local desc=$(get_local_app_desc "$app")
        printf "  [%2d] %-15s (%s)\n" "$i" "$app" "$desc"
        i=$((i + 1))
    done
    echo ""

    read -p "Select app: " app_choice

    if ! echo "$app_choice" | grep -q "^[0-9]*$" || [ "$app_choice" -lt 1 ] || [ "$app_choice" -gt "${#LOCAL_APP_NAMES[@]}" ]; then
        print_error "Invalid selection"
        return 1
    fi

    local app="${LOCAL_APP_NAMES[$((app_choice-1))]}"

    local default_name="$app-$(date +%H%M)"
    read -p "Session name [$default_name]: " session_name
    session_name="${session_name:-$default_name}"

    local work_dir="$PWD"
    read -p "Working directory [$work_dir]: " dir_input
    dir_input="${dir_input:-$work_dir}"
    dir_input="${dir_input/#\~/$HOME}"

    create_local_session "$app" "$session_name" "$dir_input"

    read -p "Attach to session now? [Y/n]: " attach
    case "$attach" in
        [Nn]*) ;;
        *) attach_session "$session_name" ;;
    esac
}

# List local apps
list_local_apps() {
    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Available Local Apps${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    if [ ${#LOCAL_APP_NAMES[@]} -eq 0 ]; then
        print_warning "No local apps configured"
        return 1
    fi

    local i=1
    for app in "${LOCAL_APP_NAMES[@]}"; do
        local desc=$(get_local_app_desc "$app")
        printf "  ${CYAN}[%2d]${NC} %-15s %s\n" "$i" "$app" "$desc"
        i=$((i + 1))
    done
    echo ""
}

# =============================================================================
# REMOTE SESSION MANAGEMENT
# =============================================================================

# List tmux sessions on a remote host
list_remote_sessions() {
    local host="$1"

    if [ -z "$host" ]; then
        print_error "Please specify a host"
        return 1
    fi

    print_info "Fetching tmux sessions on $host..."

    local sessions
    sessions=$(ssh -o ConnectTimeout=10 "$host" "tmux list-sessions 2>/dev/null" 2>/dev/null) || true

    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Remote Sessions on $host${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    if [ -z "$sessions" ]; then
        echo "  No tmux sessions running on $host"
    else
        echo "$sessions" | while read -r line; do
            echo "  $line"
        done
    fi
    echo ""
}

# Kill a tmux session on a remote host
kill_remote_session() {
    local host="$1"
    local session="$2"

    if [ -z "$host" ] || [ -z "$session" ]; then
        print_error "Usage: session-manager kill-remote <host> <session-name>"
        return 1
    fi

    print_info "Killing remote session '$session' on $host..."

    if ssh -o ConnectTimeout=10 "$host" "tmux kill-session -t '$session'" 2>/dev/null; then
        print_success "Killed remote session '$session' on $host"

        # Also kill local session if it exists
        local local_session="remote-$session"
        if tmux has-session -t "$local_session" 2>/dev/null; then
            tmux kill-session -t "$local_session" 2>/dev/null
            print_success "Killed local session '$local_session'"
        fi
    else
        print_error "Failed to kill session '$session' on $host"
        return 1
    fi
}

# Show status of all remote sessions across all hosts
show_status() {
    echo ""
    echo -e "${CYAN}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║   Session Manager - Status Dashboard                        ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Show all tmux sessions
    echo -e "${YELLOW}Sessions:${NC}"
    local all_sessions
    all_sessions=$(tmux list-sessions 2>/dev/null) || true

    if [ -z "$all_sessions" ]; then
        echo "  No tmux sessions"
    else
        echo "$all_sessions" | while read -r line; do
            local sess_name=$(echo "$line" | cut -d: -f1)
            case "$sess_name" in
                remote-*)
                    echo "  ${CYAN}●${NC} $line (remote)"
                    ;;
                *)
                    # Check if it's a local app session
                    local is_app=false
                    for app in "${LOCAL_APP_NAMES[@]}"; do
                        case "$sess_name" in
                            $app|$app-*)
                                echo "  ${GREEN}●${NC} $line (local: $app)"
                                is_app=true
                                break
                                ;;
                        esac
                    done
                    if [ "$is_app" = false ]; then
                        echo "  ${BLUE}●${NC} $line"
                    fi
                    ;;
            esac
        done
    fi
    echo ""

    # Check remote hosts with active local sessions
    echo -e "${YELLOW}Remote Hosts (checking active connections):${NC}"

    local checked_hosts=""
    for sess in $(tmux list-sessions -F "#{session_name}" 2>/dev/null); do
        case "$sess" in
            remote-*)
                local remote_part="${sess#remote-}"
                # Find the host
                for h in "${SSH_HOST_NAMES[@]}"; do
                    if [ "$remote_part" = "$h" ] || echo "$remote_part" | grep -q "^$h-"; then
                        # Check if we already checked this host
                        case "$checked_hosts" in
                            *"|$h|"*) continue ;;
                        esac
                        checked_hosts="${checked_hosts}|$h|"

                        # Get remote session count
                        local count
                        count=$(ssh -o ConnectTimeout=3 -o BatchMode=yes "$h" "tmux list-sessions 2>/dev/null | wc -l" 2>/dev/null) || count="?"
                        echo "  ${GREEN}●${NC} $h ($(get_host_display "$h")) - $count remote session(s)"
                        break
                    fi
                done
                ;;
        esac
    done

    if [ -z "$checked_hosts" ]; then
        echo "  No active remote connections"
    fi
    echo ""

    echo -e "${YELLOW}Quick Commands:${NC}"
    echo "  sm local <app>               Start local app session"
    echo "  sm <host>                    Connect to remote host"
    echo "  sm sessions <host>           List sessions on host"
    echo "  sm kill-remote <host> <sess> Kill remote session"
    echo ""
}

# Connect to host - show picker if multiple sessions exist
smart_connect() {
    local host="$1"
    local session_name="$2"
    local remote_dir="$3"
    local cmd="$4"
    local detach="$5"

    # If session name provided, connect directly
    if [ -n "$session_name" ]; then
        local full_name="remote-$host-$session_name"
        if tmux has-session -t "$full_name" 2>/dev/null; then
            print_info "Attaching to existing session '$full_name'..."
            attach_session "$full_name"
        else
            create_remote_session "$host" "$full_name" "$remote_dir" "$cmd"
            if [ "$detach" != "true" ]; then
                attach_session "$full_name"
            fi
        fi
        return 0
    fi

    # Check for existing local session for this host
    local default_session="remote-$host"
    if tmux has-session -t "$default_session" 2>/dev/null; then
        print_info "Attaching to existing session '$default_session'..."
        attach_session "$default_session"
        return 0
    fi

    # Check for other sessions for this host
    local matching_sessions=()
    for sess in $(tmux list-sessions -F "#{session_name}" 2>/dev/null); do
        case "$sess" in
            remote-$host|remote-$host-*)
                matching_sessions+=("$sess")
                ;;
        esac
    done

    if [ ${#matching_sessions[@]} -gt 1 ]; then
        # Multiple sessions - show picker
        echo ""
        print_info "Multiple sessions found for $host:"
        echo ""
        local i=1
        for sess in "${matching_sessions[@]}"; do
            echo "  [$i] $sess"
            i=$((i + 1))
        done
        echo "  [n] Create new session"
        echo ""

        read -p "Select session: " choice

        if [ "$choice" = "n" ] || [ "$choice" = "N" ]; then
            read -p "Session name: " new_name
            create_remote_session "$host" "remote-$host-$new_name" "$remote_dir" "$cmd"
            if [ "$detach" != "true" ]; then
                attach_session "remote-$host-$new_name"
            fi
        elif echo "$choice" | grep -q "^[0-9]*$" && [ "$choice" -ge 1 ] && [ "$choice" -le "${#matching_sessions[@]}" ]; then
            attach_session "${matching_sessions[$((choice-1))]}"
        else
            print_error "Invalid selection"
            return 1
        fi
    elif [ ${#matching_sessions[@]} -eq 1 ]; then
        # One session - attach to it
        print_info "Attaching to '${matching_sessions[0]}'..."
        attach_session "${matching_sessions[0]}"
    else
        # No sessions - create new
        create_remote_session "$host" "$default_session" "$remote_dir" "$cmd"
        if [ "$detach" != "true" ]; then
            attach_session "$default_session"
        fi
    fi
}

# =============================================================================
# CORE FUNCTIONALITY
# =============================================================================

# Colors for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
NC=$'\033[0m' # No Color

# Print functions
print_info() { printf "${BLUE}[INFO]${NC} %s\n" "$1"; }
print_success() { printf "${GREEN}[OK]${NC} %s\n" "$1"; }
print_warning() { printf "${YELLOW}[WARN]${NC} %s\n" "$1"; }
print_error() { printf "${RED}[ERROR]${NC} %s\n" "$1"; }

# Check if command exists
cmd_exists() {
    command -v "$1" &> /dev/null
}

# Check if tmux is available
check_tmux() {
    if ! cmd_exists tmux; then
        print_error "tmux is not installed. Install it with: sudo apt install tmux"
        exit 1
    fi
}

# List all tmux sessions
list_sessions() {
    tmux list-sessions 2>/dev/null || true
}

# Get session count
get_session_count() {
    list_sessions | wc -l
}

# =============================================================================
# REMOTE SESSION MANAGEMENT
# =============================================================================

# Create remote session - SSH to host and run agent-deck in remote tmux
create_remote_session() {
    local host="$1"
    local session_name="${2:-remote-$host}"
    local remote_dir="${3:-$REMOTE_DIR}"
    local cmd="${4:-$REMOTE_CMD}"

    # Validate host exists in config
    if ! host_exists "$host"; then
        print_error "Unknown host: $host"
        print_info "Use 'session-manager hosts' to see available hosts."
        return 1
    fi

    # Remote tmux session name (strip 'remote-' prefix for cleaner remote name)
    local remote_session="${session_name#remote-}"

    print_info "Creating remote session '$session_name'"
    print_info "Host: $host ($(get_host_display "$host"))"
    print_info "Remote tmux session: $remote_session"
    print_info "Command: $cmd"

    # Check if local session already exists
    if tmux has-session -t "$session_name" 2>/dev/null; then
        print_warning "Session '$session_name' already exists, attaching..."
        attach_session "$session_name"
        return 0
    fi

    # Build SSH command that creates/attaches to remote tmux session
    # -A: attach if session exists, create if not
    # Use login shell (-l) to ensure PATH includes ~/.local/bin etc.
    # This ensures the remote session persists even if SSH disconnects
    #
    # DETACH: Since you're in nested tmux (local -> remote):
    #   Ctrl+B D = detach from LOCAL tmux (recommended - keeps SSH alive)
    #   To detach from REMOTE only: Ctrl+B : detach (tmux command mode)
    local remote_tmux_cmd="cd $remote_dir 2>/dev/null; tmux new-session -A -s '$remote_session' 'bash -l -c \"$cmd\"'"
    local ssh_cmd="ssh -t $host \"$remote_tmux_cmd\""

    # Create local tmux session with SSH command
    tmux new-session -d -s "$session_name" bash -c "$ssh_cmd"
    print_success "Created remote session '$session_name'"
    print_info "Remote tmux session '$remote_session' on $host"
    print_info "Detach: Ctrl+B, D"
}

# Create remote session interactively
create_remote_session_interactive() {
    echo ""
    print_info "Create Remote Session"
    echo ""

    if [ ${#SSH_HOST_NAMES[@]} -eq 0 ]; then
        print_warning "No SSH hosts configured"
        print_info "Add hosts to: $SSH_CONFIG"
        return 1
    fi

    # Show hosts
    echo "Available hosts:"
    local i=1
    for host in "${SSH_HOST_NAMES[@]}"; do
        local display=$(get_host_display "$host")
        printf "  [%2d] %-20s (%s)\n" "$i" "$host" "$display"
        i=$((i + 1))
    done
    echo ""

    read -p "Select host: " host_choice

    if ! echo "$host_choice" | grep -q "^[0-9]*$" || [ "$host_choice" -lt 1 ] || [ "$host_choice" -gt "${#SSH_HOST_NAMES[@]}" ]; then
        print_error "Invalid selection"
        return 1
    fi

    local host="${SSH_HOST_NAMES[$((host_choice-1))]}"

    # Get session name
    local default_name="remote-$host"
    read -p "Session name [$default_name]: " session_name
    session_name="${session_name:-$default_name}"

    # Get remote directory
    read -p "Remote directory [$REMOTE_DIR]: " remote_dir
    remote_dir="${remote_dir:-$REMOTE_DIR}"

    # Test connection option
    read -p "Test connection first? [y/N]: " test_conn
    case "$test_conn" in
        [Yy]*)
            if ! test_ssh_connection "$host"; then
                return 1
            fi

            # Check if agent-deck is installed
            print_info "Checking if $REMOTE_CMD is installed on $host..."
            if check_remote_cmd "$host"; then
                print_success "$REMOTE_CMD found on $host"
            else
                print_warning "$REMOTE_CMD not found on $host"
                read -p "Continue anyway? [y/N]: " continue_anyway
                case "$continue_anyway" in
                    [Yy]*) ;;
                    *) return 1 ;;
                esac
            fi
            ;;
    esac

    # Create session
    create_remote_session "$host" "$session_name" "$remote_dir"

    # Ask to attach
    read -p "Attach to session now? [Y/n]: " attach
    case "$attach" in
        [Nn]*) ;;
        *) attach_session "$session_name" ;;
    esac
}

# Attach to session
attach_session() {
    local session_name="$1"
    tmux attach-session -t "$session_name"
}

# Kill session
kill_session() {
    local session_name="$1"
    tmux kill-session -t "$session_name" 2>/dev/null
    print_success "Killed session '$session_name'"
}

# Rename session
rename_session() {
    local old_name="$1"
    local new_name="$2"

    if ! tmux has-session -t "$old_name" 2>/dev/null; then
        print_error "Session '$old_name' not found"
        return 1
    fi

    if tmux has-session -t "$new_name" 2>/dev/null; then
        print_error "Session '$new_name' already exists"
        return 1
    fi

    tmux rename-session -t "$old_name" "$new_name"
    print_success "Renamed '$old_name' to '$new_name'"
}

# Rename session interactively
rename_session_interactive() {
    echo ""
    print_info "Rename a session"
    echo ""

    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

    if [ ${#sessions[@]} -eq 0 ]; then
        print_warning "No running sessions found"
        return
    fi

    echo "Running sessions:"
    local i=1
    for sess in "${sessions[@]}"; do
        echo "  [$i] $sess"
        i=$((i + 1))
    done
    echo ""

    read -p "Select session to rename (or 'q' to cancel): " choice

    case "$choice" in
        q|Q) return ;;
    esac

    if echo "$choice" | grep -q "^[0-9]*$" && [ "$choice" -ge 1 ] && [ "$choice" -le "${#sessions[@]}" ]; then
        local selected="${sessions[$((choice-1))]}"
        read -p "New name for '$selected': " new_name
        if [ -n "$new_name" ]; then
            rename_session "$selected" "$new_name"
        else
            print_error "No name provided"
        fi
    else
        print_error "Invalid selection"
    fi
}

# Show available sessions and let user pick
show_sessions() {
    echo ""
    print_info "Available sessions:"
    echo ""

    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

    if [ ${#sessions[@]} -eq 0 ]; then
        print_warning "No sessions found"
        return 1
    fi

    local i=1
    for sess in "${sessions[@]}"; do
        echo "  [$i] $sess"
        i=$((i + 1))
    done
    echo ""

    read -p "Select session number (or 'q' to cancel): " choice

    case "$choice" in
        q|Q) return 1 ;;
    esac

    if echo "$choice" | grep -q "^[0-9]*$" && [ "$choice" -ge 1 ] && [ "$choice" -le "${#sessions[@]}" ]; then
        local selected="${sessions[$((choice-1))]}"
        attach_session "$selected"
    else
        print_error "Invalid selection"
        return 1
    fi
}

# =============================================================================
# INTERACTIVE MENU
# =============================================================================

show_main_menu() {
    clear
    echo -e "${CYAN}╔════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║         Session Manager                ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════╝${NC}"
    echo ""

    # Show local apps
    echo -e "${GREEN}Local Apps:${NC} ${#LOCAL_APP_NAMES[@]} available"
    if [ ${#LOCAL_APP_NAMES[@]} -gt 0 ]; then
        local max_show=3
        local shown=0
        for app in "${LOCAL_APP_NAMES[@]}"; do
            if [ $shown -ge $max_show ]; then
                echo "  ${GREEN}...${NC} and $((${#LOCAL_APP_NAMES[@]} - max_show)) more"
                break
            fi
            local desc=$(get_local_app_desc "$app")
            echo "  ${GREEN}$app${NC} - $desc"
            shown=$((shown + 1))
        done
    fi
    echo ""

    # Show available SSH hosts
    echo -e "${CYAN}SSH Hosts:${NC} ${#SSH_HOST_NAMES[@]} configured"
    if [ ${#SSH_HOST_NAMES[@]} -gt 0 ]; then
        local max_show=5
        local shown=0
        for host in "${SSH_HOST_NAMES[@]}"; do
            if [ $shown -ge $max_show ]; then
                echo "  ${CYAN}...${NC} and $((${#SSH_HOST_NAMES[@]} - max_show)) more"
                break
            fi
            echo "  ${CYAN}$host${NC} - $(get_host_display "$host")"
            shown=$((shown + 1))
        done
    fi
    echo ""

    # Show running sessions
    local count=$(get_session_count)
    echo "Running sessions: $count"
    echo ""

    echo "Options:"
    echo "  ${GREEN}[1] Create local session${NC}"
    echo "  ${CYAN}[2] Connect to remote host${NC}"
    echo "  [3] Attach to session"
    echo "  [4] List sessions"
    echo "  [5] Kill session"
    echo "  [6] Rename session"
    echo "  [7] List local apps"
    echo "  [8] List SSH hosts"
    echo "  [9] List remote sessions on host"
    echo "  [s] Status dashboard"
    echo "  [t] Test SSH connection"
    echo "  [c] Configure"
    echo "  [q] Quit"
    echo ""
}

# Kill session interactively
kill_session_interactive() {
    echo ""
    print_info "Kill a session"
    echo ""

    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

    if [ ${#sessions[@]} -eq 0 ]; then
        print_warning "No running sessions found"
        return
    fi

    echo "Running sessions:"
    local i=1
    for sess in "${sessions[@]}"; do
        echo "  [$i] $sess"
        i=$((i + 1))
    done
    echo ""

    read -p "Select session to kill (or 'q' to cancel): " choice

    case "$choice" in
        q|Q) return ;;
    esac

    if echo "$choice" | grep -q "^[0-9]*$" && [ "$choice" -ge 1 ] && [ "$choice" -le "${#sessions[@]}" ]; then
        local selected="${sessions[$((choice-1))]}"
        read -p "Confirm kill session '$selected'? [y/N]: " confirm
        case "$confirm" in
            [Yy]*) kill_session "$selected" ;;
        esac
    else
        print_error "Invalid selection"
    fi
}

# List all sessions with formatting
list_all_sessions() {
    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Running Sessions${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    if list_sessions | head -1 > /dev/null 2>&1; then
        list_sessions
    else
        echo "  No sessions running"
    fi
    echo ""
}

# Get session info
show_session_info() {
    local session_name="$1"

    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        print_error "Session '$session_name' not found"
        return 1
    fi

    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Session Info: $session_name${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    # Get session details
    local session_info=$(tmux list-sessions -F "#{session_name}: #{?session_attached,(attached),(detached)} - #{window_name}" 2>/dev/null | grep "^$session_name:")

    if [ -n "$session_info" ]; then
        echo "  Status: $session_info"
    fi

    # Check if this is a remote session
    case "$session_name" in
        remote-*)
            local remote_part="${session_name#remote-}"
            # Try to find the host in our registry
            local found_host=""
            for h in "${SSH_HOST_NAMES[@]}"; do
                if [ "$remote_part" = "$h" ] || echo "$remote_part" | grep -q "^$h-"; then
                    found_host="$h"
                    break
                fi
            done
            if [ -n "$found_host" ]; then
                echo "  Type: Remote (SSH + tmux)"
                echo "  Host: $found_host ($(get_host_display "$found_host"))"
                echo "  Remote tmux session: $remote_part"
            fi
            ;;
    esac

    # List windows
    echo ""
    echo "  Windows:"
    tmux list-windows -t "$session_name" 2>/dev/null | while read -r window; do
        echo "    $window"
    done
    echo ""
}

# Restart remote session
restart_session() {
    local session_name="$1"

    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        print_error "Session '$session_name' not found"
        return 1
    fi

    print_info "Restarting session '$session_name'"

    # Check if this is a remote session
    case "$session_name" in
        remote-*)
            local host="${session_name#remote-}"
            # Handle session names like remote-hostname-suffix
            # Try to find the host in our registry
            local found_host=""
            for h in "${SSH_HOST_NAMES[@]}"; do
                if [ "$session_name" = "remote-$h" ] || echo "$session_name" | grep -q "^remote-$h-"; then
                    found_host="$h"
                    break
                fi
            done

            if [ -n "$found_host" ]; then
                kill_session "$session_name"
                create_remote_session "$found_host" "$session_name"
                print_success "Restarted remote session '$session_name'"
                return 0
            fi
            ;;
    esac

    print_warning "Cannot restart session - unknown type"
    print_info "Kill and recreate the session manually"
    return 1
}

# Test SSH connection interactively
test_ssh_interactive() {
    echo ""
    print_info "Test SSH Connection"
    echo ""

    if [ ${#SSH_HOST_NAMES[@]} -eq 0 ]; then
        print_warning "No SSH hosts configured"
        return 1
    fi

    echo "Available hosts:"
    local i=1
    for host in "${SSH_HOST_NAMES[@]}"; do
        local display=$(get_host_display "$host")
        printf "  [%2d] %-20s (%s)\n" "$i" "$host" "$display"
        i=$((i + 1))
    done
    echo ""

    read -p "Select host to test: " choice

    if ! echo "$choice" | grep -q "^[0-9]*$" || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#SSH_HOST_NAMES[@]}" ]; then
        print_error "Invalid selection"
        return 1
    fi

    local host="${SSH_HOST_NAMES[$((choice-1))]}"

    test_ssh_connection "$host"

    # Also check for agent-deck
    echo ""
    print_info "Checking for $REMOTE_CMD on $host..."
    if check_remote_cmd "$host"; then
        print_success "$REMOTE_CMD is installed on $host"
    else
        print_warning "$REMOTE_CMD not found on $host"
        print_info "You may need to install AgentDeck on the remote system"
    fi
}

# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

show_help() {
    cat << 'EOF'
Usage: sm <host> [name]                   Start remote session on SSH host
   or: sm local <app> [name]              Start local session with app
   or: sm local-apps                      List available local apps
   or: sm hosts                           List available SSH hosts
   or: sm status                          Dashboard of all sessions
   or: sm sessions <host>                 List tmux sessions on remote host
   or: sm list                            List local tmux sessions
   or: sm attach <name>                   Attach to session
   or: sm kill <name>                     Kill session
   or: sm kill-remote <host> <session>    Kill remote tmux session
   or: sm rename <old> <new>              Rename a session
   or: sm info <name>                     Show session details
   or: sm restart <name>                  Restart a session
   or: sm test <host>                     Test SSH connection
   or: sm config                          Configure settings
   or: sm                                 Interactive menu
   or: sm --version                       Show version

Options:
  --detach, -d                        Create session without attaching
  --dir <path>, -D <path>             Specify working directory

Session naming patterns:
  Local:  <app>-<name>           (e.g., claude-myproject)
  Remote: remote-<host>[-name]   (e.g., remote-dev-myproject)

Local Session Examples:
  sm local bash                            Start bash session
  sm local claude                          Start Claude Code session
  sm local claude myproject                Named Claude session
  sm local opencode -D ~/code              Start opencode in specific directory
  sm local-apps                            List available apps

Remote Session Examples:
  sm dev                                   Connect to dev (creates or attaches)
  sm dev project                           Named session on dev
  sm dev --detach                          Create without attaching
  sm dev -D ~/code                         Start in specific remote directory

  sm status                                Show all sessions dashboard
  sm hosts                                 List available SSH hosts
  sm sessions dev                          List tmux sessions on dev
  sm list                                  List local sessions

  sm attach remote-dev                     Attach to local session
  sm kill remote-dev                       Kill local session
  sm kill-remote dev mysession             Kill remote tmux session

  sm test dev                              Test SSH connection
  sm config                                Configure settings

Detaching:
  Ctrl+B, D                               Detach from session (keeps it running)

SSH Configuration:
  Hosts are read from your SSH config file (~/.ssh/config).
  Add hosts there to make them available in session-manager.

  Example ~/.ssh/config:
    Host myserver
        Hostname 192.168.1.100
        User myuser

    Host devbox
        Hostname dev.example.com
        User developer
        Port 2222

How it works:
  When you connect to a remote host, session-manager creates:
    1. A local tmux session (for managing the SSH connection)
    2. A remote tmux session (for persisting AgentDeck)

  This means AgentDeck keeps running on the remote even if:
    - Your SSH connection drops
    - You detach from the local session
    - You close your terminal

  Reconnecting will reattach to the existing remote AgentDeck session.

Configuration:
  Run 'session-manager config' to set options.
  Config file location: ~/.config/session-manager/config

Environment Variables:
  SESSION_MANAGER_SSH_CONFIG     SSH config file (default: ~/.ssh/config)
  SESSION_MANAGER_REMOTE_CMD     Command to run on remote (default: bash)
  SESSION_MANAGER_REMOTE_DIR     Default remote directory (default: ~)

EOF
}

# Configure environment variables
configure() {
    local config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/session-manager"
    local config_file="$config_dir/config"

    echo ""
    print_info "Session Manager Configuration"
    echo ""

    mkdir -p "$config_dir"

    if [ -f "$config_file" ]; then
        print_info "Existing configuration found:"
        cat "$config_file"
        echo ""
        read -p "Overwrite existing config? [y/N]: " overwrite
        case "$overwrite" in
            [Yy]*) ;;
            *) print_info "Keeping existing configuration."; return 0 ;;
        esac
    fi

    echo ""
    echo "Configure Remote AgentDeck Settings:"
    echo "Leave blank to use defaults."
    echo ""

    # Start fresh config file
    echo "# Session Manager Configuration" > "$config_file"
    echo "# Generated on $(date)" >> "$config_file"
    echo "" >> "$config_file"

    read -p "SSH config file [$HOME/.ssh/config]: " ssh_config
    if [ -n "$ssh_config" ]; then
        echo "export SESSION_MANAGER_SSH_CONFIG='$ssh_config'" >> "$config_file"
    fi

    read -p "Remote command [bash]: " remote_cmd
    if [ -n "$remote_cmd" ]; then
        echo "export SESSION_MANAGER_REMOTE_CMD='$remote_cmd'" >> "$config_file"
    fi

    read -p "Default remote directory [~]: " remote_dir
    if [ -n "$remote_dir" ]; then
        echo "export SESSION_MANAGER_REMOTE_DIR='$remote_dir'" >> "$config_file"
    fi

    chmod 600 "$config_file"
    print_success "Configuration saved to $config_file"
    print_info "Restart your shell or run: source $config_file"
}

main() {
    check_tmux

    # Parse SSH config at startup
    parse_ssh_config

    # Handle global flags first
    local detach=false
    local remote_dir="$REMOTE_DIR"
    local custom_cmd=""

    for arg in "$@"; do
        case "$arg" in
            --version|-V)
                echo "session-manager version $VERSION"
                exit 0
                ;;
        esac
    done

    # No arguments - interactive mode
    if [ $# -eq 0 ]; then
        while true; do
            show_main_menu
            read -p "Select option: " choice

            case "$choice" in
                1)
                    create_local_session_interactive
                    ;;
                2)
                    create_remote_session_interactive
                    ;;
                3)
                    show_sessions
                    ;;
                4)
                    list_all_sessions
                    read -p "Press Enter to continue..."
                    ;;
                5)
                    kill_session_interactive
                    read -p "Press Enter to continue..."
                    ;;
                6)
                    rename_session_interactive
                    read -p "Press Enter to continue..."
                    ;;
                7)
                    list_local_apps
                    read -p "Press Enter to continue..."
                    ;;
                8)
                    list_ssh_hosts
                    read -p "Press Enter to continue..."
                    ;;
                9)
                    # List remote sessions on a host
                    echo ""
                    print_info "List Remote Sessions"
                    echo ""

                    if [ ${#SSH_HOST_NAMES[@]} -eq 0 ]; then
                        print_warning "No SSH hosts configured"
                        read -p "Press Enter to continue..."
                        continue
                    fi

                    echo "Select host:"
                    local i=1
                    for host in "${SSH_HOST_NAMES[@]}"; do
                        printf "  [%2d] %s\n" "$i" "$host"
                        i=$((i + 1))
                    done
                    echo ""

                    read -p "Host number: " host_choice

                    if echo "$host_choice" | grep -q "^[0-9]*$" && [ "$host_choice" -ge 1 ] && [ "$host_choice" -le "${#SSH_HOST_NAMES[@]}" ]; then
                        local selected_host="${SSH_HOST_NAMES[$((host_choice-1))]}"
                        list_remote_sessions "$selected_host"
                    fi
                    read -p "Press Enter to continue..."
                    ;;
                s|S)
                    show_status
                    read -p "Press Enter to continue..."
                    ;;
                t|T)
                    test_ssh_interactive
                    read -p "Press Enter to continue..."
                    ;;
                c|C)
                    configure
                    read -p "Press Enter to continue..."
                    ;;
                q|Q)
                    print_info "Goodbye!"
                    exit 0
                    ;;
                *)
                    print_error "Invalid option"
                    read -p "Press Enter to continue..."
                    ;;
            esac
        done
    fi

    # Command line mode
    local cmd="$1"
    shift || true

    case "$cmd" in
        -h|--help|help)
            show_help
            exit 0
            ;;
        config)
            configure
            exit 0
            ;;
        hosts)
            list_ssh_hosts
            exit 0
            ;;
        local-apps)
            list_local_apps
            exit 0
            ;;
        local)
            # Handle: sm local <app> [name] [options]
            local app="$1"
            shift || true
            local session_name=""
            local work_dir="$PWD"

            while [ $# -gt 0 ]; do
                case "$1" in
                    --detach|-d) detach=true; shift ;;
                    --dir|-D) work_dir="$2"; shift 2 ;;
                    *)
                        if [ -z "$session_name" ]; then
                            session_name="$1"
                        fi
                        shift
                        ;;
                esac
            done

            if [ -z "$app" ]; then
                create_local_session_interactive
                exit 0
            fi

            if ! local_app_exists "$app"; then
                print_error "Unknown local app: $app"
                list_local_apps
                exit 1
            fi

            work_dir="${work_dir/#\~/$HOME}"
            session_name="${session_name:-$(date +%H%M)}"
            # Prepend app name if not already included
            case "$session_name" in
                $app|$app-*) ;;
                *) session_name="$app-$session_name" ;;
            esac

            if tmux has-session -t "$session_name" 2>/dev/null; then
                print_info "Attaching to existing session '$session_name'..."
                attach_session "$session_name"
            else
                create_local_session "$app" "$session_name" "$work_dir"
                if [ "$detach" != true ]; then
                    attach_session "$session_name"
                fi
            fi
            exit 0
            ;;
        list)
            list_all_sessions
            exit 0
            ;;
        attach)
            local attach_name="$1"

            while [ $# -gt 0 ]; do
                case "$1" in
                    --detach|-d)
                        print_error "--detach flag not valid with attach command"
                        exit 1
                        ;;
                esac
                shift
            done

            if [ -z "$attach_name" ]; then
                show_sessions
            else
                attach_session "$attach_name"
            fi
            exit 0
            ;;
        kill)
            local kill_name="$1"
            if [ -z "$kill_name" ]; then
                kill_session_interactive
            else
                kill_session "$kill_name"
            fi
            exit 0
            ;;
        info)
            local info_name="$1"
            if [ -z "$info_name" ]; then
                print_error "Please specify a session name"
                exit 1
            fi
            show_session_info "$info_name"
            exit 0
            ;;
        restart)
            local restart_name="$1"
            if [ -z "$restart_name" ]; then
                print_error "Please specify a session name"
                exit 1
            fi
            restart_session "$restart_name"
            exit 0
            ;;
        rename)
            local old_name="$1"
            local new_name="$2"
            if [ -z "$old_name" ]; then
                rename_session_interactive
            elif [ -z "$new_name" ]; then
                print_error "Usage: sm rename <old-name> <new-name>"
                exit 1
            else
                rename_session "$old_name" "$new_name"
            fi
            exit 0
            ;;
        test)
            local test_host="$1"
            if [ -z "$test_host" ]; then
                test_ssh_interactive
            else
                test_ssh_connection "$test_host"
                echo ""
                print_info "Checking for $REMOTE_CMD on $test_host..."
                if check_remote_cmd "$test_host"; then
                    print_success "$REMOTE_CMD is installed on $test_host"
                else
                    print_warning "$REMOTE_CMD not found on $test_host"
                fi
            fi
            exit 0
            ;;
        status)
            show_status
            exit 0
            ;;
        sessions)
            local sessions_host="$1"
            if [ -z "$sessions_host" ]; then
                print_error "Please specify a host"
                print_info "Usage: session-manager sessions <host>"
                exit 1
            fi
            list_remote_sessions "$sessions_host"
            exit 0
            ;;
        kill-remote)
            local kr_host="$1"
            local kr_session="$2"
            kill_remote_session "$kr_host" "$kr_session"
            exit 0
            ;;
        *)
            # Treat first arg as host name, parse remaining args for flags
            local host="$cmd"
            local session_name=""

            # Parse arguments
            while [ $# -gt 0 ]; do
                case "$1" in
                    --detach|-d)
                        detach=true
                        shift
                        ;;
                    --dir|-D)
                        remote_dir="$2"
                        shift 2
                        ;;
                    --cmd)
                        custom_cmd="$2"
                        shift 2
                        ;;
                    *)
                        if [ -z "$session_name" ]; then
                            session_name="$1"
                        fi
                        shift
                        ;;
                esac
            done

            # Validate host exists in SSH config
            if ! host_exists "$host"; then
                print_error "Unknown host: $host"
                print_info "Use 'sm hosts' to see available SSH hosts."
                print_info "Add hosts to your SSH config: $SSH_CONFIG"
                exit 1
            fi

            # Use custom command if provided
            local cmd_to_run="${custom_cmd:-$REMOTE_CMD}"

            # Use smart connect for better UX with multiple sessions
            local detach_flag="false"
            if [ "$detach" = true ]; then
                detach_flag="true"
            fi

            smart_connect "$host" "$session_name" "$remote_dir" "$cmd_to_run" "$detach_flag"
            exit 0
            ;;
    esac
}

main "$@"
