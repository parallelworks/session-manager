#!/bin/bash
# session-manager - Run commands in persistent tmux sessions

set -e

VERSION="1.2.0"

# =============================================================================
# CONFIGURATION - Load config file if exists
# =============================================================================

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/session-manager"
CONFIG_FILE="$CONFIG_DIR/config"

if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# =============================================================================
# APP REGISTRY - Add new apps here
# =============================================================================

declare -A APP_CMDS
declare -A APP_DESCS
declare -A APP_ENVS
declare -a APP_ORDER

# Register an app with command, description, and optional environment variables
register_app() {
    local app="$1"
    local cmd="$2"
    local desc="$3"
    local envs="${4:-}"

    APP_CMDS[$app]="$cmd"
    APP_DESCS[$app]="$desc"
    if [ -n "$envs" ]; then
        APP_ENVS[$app]="$envs"
    fi

    APP_ORDER+=("$app")
}

# =============================================================================
# BUILT-IN APPS
# =============================================================================

# Interactive bash shell
register_app "bash" "bash --login" \
    "Interactive bash shell" \
    ""

# OpenCode editor (terminal TUI)
register_app "opencode" "opencode" \
    "OpenCode editor TUI" \
    ""

# Claude Code CLI - configure via env vars or config file
register_app "claude" "claude --dangerously-skip-permissions" \
    "Claude Code CLI" \
    "COLORTERM=truecolor ANTHROPIC_BASE_URL=\${SESSION_MANAGER_ANTHROPIC_BASE_URL:-https://api.anthropic.com} API_TIMEOUT_MS=\${SESSION_MANAGER_API_TIMEOUT_MS:-3000000} ANTHROPIC_DEFAULT_HAIKU_MODEL=\${SESSION_MANAGER_HAIKU_MODEL:-claude-3-5-haiku} ANTHROPIC_DEFAULT_SONNET_MODEL=\${SESSION_MANAGER_SONNET_MODEL:-claude-3-5-sonnet} ANTHROPIC_DEFAULT_OPUS_MODEL=\${SESSION_MANAGER_OPUS_MODEL:-claude-3-opus} ANTHROPIC_AUTH_TOKEN=\${SESSION_MANAGER_ANTHROPIC_AUTH_TOKEN}"

# =============================================================================
# ADD YOUR CUSTOM APPS BELOW
# =============================================================================

# Examples (uncomment and modify as needed):
#
# register_app "python" "python3" \
#     "Python REPL" \
#     ""
#
# register_app "node" "node" \
#     "Node.js REPL" \
#     ""

# =============================================================================
# CORE FUNCTIONALITY
# =============================================================================

# Colors for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
NC=$'\033[0m' # No Color

# Print functions
print_info() { printf "${BLUE}[INFO]${NC} %s\n" "$1"; }
print_success() { printf "${GREEN}[OK]${NC} %s\n" "$1"; }
print_warning() { printf "${YELLOW}[WARN]${NC} %s\n" "$1"; }
print_error() { printf "${RED}[ERROR]${NC} %s\n" "$1"; }

# Check if command exists
cmd_exists() {
    command -v "$1" &> /dev/null
}

# Check if tmux is available
check_tmux() {
    if ! cmd_exists tmux; then
        print_error "tmux is not installed. Install it with: sudo apt install tmux"
        exit 1
    fi
}

# List all tmux sessions
list_sessions() {
    tmux list-sessions 2>/dev/null || true
}

# Get session count
get_session_count() {
    list_sessions | wc -l
}

# List available apps
list_apps() {
    echo ""
    echo -e "${CYAN}Available Apps:${NC}"
    echo ""

    local max_len=0
    for app in "${APP_ORDER[@]}"; do
        [ ${#app} -gt $max_len ] && max_len=${#app}
    done

    for app in "${APP_ORDER[@]}"; do
        printf "  ${CYAN}%-${max_len}s${NC}  %s\n" "$app" "${APP_DESCS[$app]}"
    done
    echo ""
}

# Get app command
get_app_cmd() {
    local app="$1"
    if [ -z "${APP_CMDS[$app]}" ]; then
        return 1
    fi
    echo "${APP_CMDS[$app]}"
}

# Get app description
get_app_desc() {
    local app="$1"
    echo "${APP_DESCS[$app]:-}"
}

# Get app environment variables
get_app_env() {
    local app="$1"
    echo "${APP_ENVS[$app]:-}"
}

# Create new session for an app
create_session() {
    local app="$1"
    local session_name="$2"
    local work_dir="${3:-$PWD}"
    local cmd
    local envs

    cmd=$(get_app_cmd "$app") || {
        print_error "Unknown app: $app"
        print_info "Use 'session-manager list-apps' to see available apps."
        return 1
    }

    envs=$(get_app_env "$app")

    print_info "Creating session '$session_name' in $work_dir"
    print_info "App: $app - ${APP_DESCS[$app]}"

    # Check if session already exists
    if tmux has-session -t "$session_name" 2>/dev/null; then
        print_warning "Session '$session_name' already exists, attaching..."
        attach_session "$session_name"
        return 0
    fi

    # Check if working directory exists
    if [ ! -d "$work_dir" ]; then
        print_error "Directory does not exist: $work_dir"
        return 1
    fi

    # Build the command with environment variables
    local full_cmd=""
    if [ -n "$envs" ]; then
        full_cmd="export $envs && exec $cmd"
    else
        full_cmd="exec $cmd"
    fi

    # Create session
    tmux new-session -d -s "$session_name" -c "$work_dir" bash -c "$full_cmd"
    print_success "Created session '$session_name'"
}

# Attach to session
attach_session() {
    local session_name="$1"
    tmux attach-session -t "$session_name"
}

# Kill session
kill_session() {
    local session_name="$1"
    tmux kill-session -t "$session_name" 2>/dev/null
    print_success "Killed session '$session_name'"
}

# Show available sessions and let user pick
show_sessions() {
    echo ""
    print_info "Available sessions:"
    echo ""

    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

    if [ ${#sessions[@]} -eq 0 ]; then
        print_warning "No sessions found"
        return 1
    fi

    local i=1
    for sess in "${sessions[@]}"; do
        echo "  [$i] $sess"
        ((i++))
    done
    echo ""

    read -p "Select session number (or 'q' to cancel): " choice

    if [[ "$choice" == "q" ]]; then
        return 1
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#sessions[@]}" ]; then
        local selected="${sessions[$((choice-1))]}"
        attach_session "$selected"
    else
        print_error "Invalid selection"
        return 1
    fi
}

# =============================================================================
# INTERACTIVE MENU
# =============================================================================

show_main_menu() {
    clear
    echo -e "${CYAN}╔════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║   Session Manager                      ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════╝${NC}"
    echo ""

    # Show available apps
    echo "Available apps:"
    for app in "${APP_ORDER[@]}"; do
        echo "  ${CYAN}$app${NC} - ${APP_DESCS[$app]}"
    done
    echo ""

    # Show running sessions
    local count=$(get_session_count)
    echo "Running sessions: $count"
    echo ""

    echo "Options:"
    echo "  [1] Create new session"
    echo "  [2] Attach to session"
    echo "  [3] List sessions"
    echo "  [4] Kill session"
    echo "  [5] List apps"
    echo "  [6] Configure"
    echo "  [7] Session info"
    echo "  [8] Restart session"
    echo "  [q] Quit"
    echo ""
}

# Create session interactively
create_session_interactive() {
    echo ""
    print_info "Create new session"
    echo ""

    # Select app
    echo "Available apps:"
    local apps=("${APP_ORDER[@]}")
    local i=1
    for app in "${apps[@]}"; do
        echo "  [$i] $app - ${APP_DESCS[$app]}"
        ((i++))
    done
    echo ""

    read -p "Select app: " app_choice

    if [[ ! "$app_choice" =~ ^[0-9]+$ ]] || [ "$app_choice" -lt 1 ] || [ "$app_choice" -gt "${#apps[@]}" ]; then
        print_error "Invalid selection"
        return 1
    fi

    local app="${apps[$((app_choice-1))]}"

    # Get session name
    local default_name="$app-$(date +%H%M)"
    read -p "Session name [$default_name]: " session_name
    session_name="${session_name:-$default_name}"

    # Get working directory
    local work_dir="$PWD"
    read -p "Working directory [$work_dir]: " dir_input
    work_dir="${dir_input:-$work_dir}"
    work_dir="${work_dir/#\~/$HOME}"

    # Create session
    create_session "$app" "$session_name" "$work_dir"

    # Ask to attach
    read -p "Attach to session now? [Y/n]: " attach
    if [[ ! "$attach" =~ ^[Nn]$ ]]; then
        attach_session "$session_name"
    fi
}

# Kill session interactively
kill_session_interactive() {
    echo ""
    print_info "Kill a session"
    echo ""

    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

    if [ ${#sessions[@]} -eq 0 ]; then
        print_warning "No running sessions found"
        return
    fi

    echo "Running sessions:"
    local i=1
    for sess in "${sessions[@]}"; do
        echo "  [$i] $sess"
        ((i++))
    done
    echo ""

    read -p "Select session to kill (or 'q' to cancel): " choice

    if [[ "$choice" == "q" ]]; then
        return
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#sessions[@]}" ]; then
        local selected="${sessions[$((choice-1))]}"
        read -p "Confirm kill session '$selected'? [y/N]: " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            kill_session "$selected"
        fi
    else
        print_error "Invalid selection"
    fi
}

# List all sessions with formatting
list_all_sessions() {
    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Running Sessions${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    if list_sessions | head -1 > /dev/null 2>&1; then
        list_sessions
    else
        echo "  No sessions running"
    fi
    echo ""
}

# Get session info
show_session_info() {
    local session_name="$1"

    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        print_error "Session '$session_name' not found"
        return 1
    fi

    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Session Info: $session_name${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""

    # Get session details
    local session_info=$(tmux list-sessions -F "#{session_name}: #{?session_attached,(attached),(detached)} - #{window_name}" 2>/dev/null | grep "^$session_name:")

    if [ -n "$session_info" ]; then
        echo "  Status: $session_info"
    fi

    # Get working directory
    local work_dir=$(tmux display-message -p -t "$session_name" "#{pane_current_path}")
    echo "  Working Directory: $work_dir"

    # Get running command
    local cmd=$(tmux send-keys -t "$session_name" 'echo $$' C-m 2>/dev/null && sleep 0.1 && tmux capture-pane -p -t "$session_name" | tail -1)
    echo ""

    # List windows
    echo "  Windows:"
    tmux list-windows -t "$session_name" 2>/dev/null | while read -r window; do
        echo "    $window"
    done
    echo ""
}

# Restart session
restart_session() {
    local session_name="$1"

    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        print_error "Session '$session_name' not found"
        return 1
    fi

    print_info "Restarting session '$session_name'"

    # Extract app name from session name (remove suffix after dash)
    local app=$(echo "$session_name" | sed 's/-.*//')

    # Get current working directory
    local work_dir=$(tmux display-message -p -t "$session_name" "#{pane_current_path}")

    # Kill and recreate
    kill_session "$session_name"

    # Check if app still exists
    if [ -z "${APP_CMDS[$app]}" ]; then
        print_warning "App '$app' no longer exists in registry"
        return 1
    fi

    # Create new session
    create_session "$app" "$session_name" "$work_dir"

    print_success "Restarted session '$session_name'"
}

# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

show_help() {
    cat << 'EOF'
Usage: session-manager <app> [name]           Create or attach to <app> session
   or: session-manager <app> [name] [options]  Create session with options
   or: session-manager attach <name>          Attach to specific session
   or: session-manager list                   List all sessions
   or: session-manager list-apps              List available apps
   or: session-manager kill <name>            Kill a session
   or: session-manager info <name>            Show session details
   or: session-manager restart <name>         Restart a session
   or: session-manager config                 Configure environment variables
   or: session-manager                        Interactive menu
   or: session-manager --version              Show version

Options:
  --detach, -d                        Create session without attaching
  --dir <path>, -D <path>             Specify working directory

Session naming pattern: <app>-<name>
Example: session-manager claude myproject  →  creates session "claude-myproject"

Examples:
  session-manager claude myproject               Create/attach to claude session
  session-manager claude myproject --detach      Create session without attaching
  session-manager bash scratch -D ~/projects     Create bash session in specific directory
  session-manager list                           List all sessions
  session-manager attach claude-myproject        Attach to specific session
  session-manager info claude-myproject          Show session details
  session-manager restart claude-myproject       Restart a session
  session-manager kill claude-myproject          Kill a session
  session-manager list-apps                      List available apps
  session-manager config                         Configure app environment variables
  session-manager --version                      Show version

Adding new apps:
  Edit the session-manager script and add a register_app call:

    register_app "myapp" "myapp --daemon" \
        "My custom application" \
        "API_KEY=\${SESSION_MANAGER_API_KEY} DEBUG=true"

Configuration:
  Run 'session-manager config' to set environment variables.
  Config file location: ~/.config/session-manager/config

EOF
}

# Configure environment variables
configure() {
    local config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/session-manager"
    local config_file="$config_dir/config"

    echo ""
    print_info "Session Manager Configuration"
    echo ""

    mkdir -p "$config_dir"

    if [ -f "$config_file" ]; then
        print_info "Existing configuration found:"
        cat "$config_file"
        echo ""
        read -p "Overwrite existing config? [y/N]: " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
            print_info "Keeping existing configuration."
            return 0
        fi
    fi

    echo ""
    echo "Configure Claude Code CLI (optional):"
    echo "Leave blank to skip."
    echo ""

    read -p "ANTHROPIC_AUTH_TOKEN: " auth_token
    if [ -n "$auth_token" ]; then
        echo "export SESSION_MANAGER_ANTHROPIC_AUTH_TOKEN='$auth_token'" > "$config_file"
    fi

    read -p "ANTHROPIC_BASE_URL [https://api.anthropic.com]: " base_url
    base_url="${base_url:-https://api.anthropic.com}"
    echo "export SESSION_MANAGER_ANTHROPIC_BASE_URL='$base_url'" >> "$config_file"

    read -p "API_TIMEOUT_MS [3000000]: " timeout
    timeout="${timeout:-3000000}"
    echo "export SESSION_MANAGER_API_TIMEOUT_MS='$timeout'" >> "$config_file"

    read -p "HAIKU_MODEL [claude-3-5-haiku]: " haiku_model
    haiku_model="${haiku_model:-claude-3-5-haiku}"
    echo "export SESSION_MANAGER_HAIKU_MODEL='$haiku_model'" >> "$config_file"

    read -p "SONNET_MODEL [claude-3-5-sonnet]: " sonnet_model
    sonnet_model="${sonnet_model:-claude-3-5-sonnet}"
    echo "export SESSION_MANAGER_SONNET_MODEL='$sonnet_model'" >> "$config_file"

    read -p "OPUS_MODEL [claude-3-opus]: " opus_model
    opus_model="${opus_model:-claude-3-opus}"
    echo "export SESSION_MANAGER_OPUS_MODEL='$opus_model'" >> "$config_file"

    chmod 600 "$config_file"
    print_success "Configuration saved to $config_file"
    print_info "Restart your shell or run: source $config_file"
}

main() {
    check_tmux

    # Handle global flags first
    local detach=false
    local work_dir="$PWD"

    for arg in "$@"; do
        case "$arg" in
            --version|-V)
                echo "session-manager version $VERSION"
                exit 0
                ;;
        esac
    done

    # No arguments - interactive mode
    if [ $# -eq 0 ]; then
        while true; do
            show_main_menu
            read -p "Select option: " choice

            case "$choice" in
                1)
                    create_session_interactive
                    ;;
                2)
                    show_sessions
                    ;;
                3)
                    list_all_sessions
                    read -p "Press Enter to continue..."
                    ;;
                4)
                    kill_session_interactive
                    read -p "Press Enter to continue..."
                    ;;
                5)
                    list_apps
                    read -p "Press Enter to continue..."
                    ;;
                6)
                    configure
                    read -p "Press Enter to continue..."
                    ;;
                7)
                    echo ""
                    print_info "Session Info"
                    echo ""

                    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

                    if [ ${#sessions[@]} -eq 0 ]; then
                        print_warning "No running sessions found"
                        read -p "Press Enter to continue..."
                        continue
                    fi

                    echo "Running sessions:"
                    local i=1
                    for sess in "${sessions[@]}"; do
                        echo "  [$i] $sess"
                        ((i++))
                    done
                    echo ""

                    read -p "Select session: " info_choice

                    if [[ "$info_choice" =~ ^[0-9]+$ ]] && [ "$info_choice" -ge 1 ] && [ "$info_choice" -le "${#sessions[@]}" ]; then
                        local selected="${sessions[$((info_choice-1))]}"
                        show_session_info "$selected"
                        read -p "Press Enter to continue..."
                    fi
                    ;;
                8)
                    echo ""
                    print_info "Restart Session"
                    echo ""

                    local sessions=($(tmux list-sessions 2>/dev/null | sed 's/:.*$//'))

                    if [ ${#sessions[@]} -eq 0 ]; then
                        print_warning "No running sessions found"
                        read -p "Press Enter to continue..."
                        continue
                    fi

                    echo "Running sessions:"
                    local i=1
                    for sess in "${sessions[@]}"; do
                        echo "  [$i] $sess"
                        ((i++))
                    done
                    echo ""

                    read -p "Select session to restart: " restart_choice

                    if [[ "$restart_choice" =~ ^[0-9]+$ ]] && [ "$restart_choice" -ge 1 ] && [ "$restart_choice" -le "${#sessions[@]}" ]; then
                        local selected="${sessions[$((restart_choice-1))]}"
                        restart_session "$selected"
                        read -p "Press Enter to continue..."
                    fi
                    ;;
                q|Q)
                    print_info "Goodbye!"
                    exit 0
                    ;;
                *)
                    print_error "Invalid option"
                    read -p "Press Enter to continue..."
                    ;;
            esac
        done
    fi

    # Command line mode
    local cmd="$1"
    shift || true

    case "$cmd" in
        -h|--help|help)
            show_help
            exit 0
            ;;
        config)
            configure
            exit 0
            ;;
        list-apps)
            list_apps
            exit 0
            ;;
        list)
            list_all_sessions
            exit 0
            ;;
        attach)
            local attach_name="$1"

            while [ $# -gt 0 ]; do
                case "$1" in
                    --detach|-d)
                        print_error "--detach flag not valid with attach command"
                        exit 1
                        ;;
                esac
                shift
            done

            if [ -z "$attach_name" ]; then
                show_sessions
            else
                attach_session "$attach_name"
            fi
            exit 0
            ;;
        kill)
            local kill_name="$1"
            if [ -z "$kill_name" ]; then
                kill_session_interactive
            else
                kill_session "$kill_name"
            fi
            exit 0
            ;;
        info)
            local info_name="$1"
            if [ -z "$info_name" ]; then
                print_error "Please specify a session name"
                exit 1
            fi
            show_session_info "$info_name"
            exit 0
            ;;
        restart)
            local restart_name="$1"
            if [ -z "$restart_name" ]; then
                print_error "Please specify a session name"
                exit 1
            fi
            restart_session "$restart_name"
            exit 0
            ;;
        *)
            # Treat first arg as app name, parse remaining args for flags
            local app="$cmd"
            local session_name=""
            local args=("$@")

            # Parse arguments
            while [ $# -gt 0 ]; do
                case "$1" in
                    --detach|-d)
                        detach=true
                        shift
                        ;;
                    --dir|-D)
                        work_dir="$2"
                        shift 2
                        ;;
                    *)
                        if [ -z "$session_name" ]; then
                            session_name="$1"
                        fi
                        shift
                        ;;
                esac
            done

            # Validate app exists
            if [ -z "${APP_CMDS[$app]}" ]; then
                print_error "Unknown app: $app"
                print_info "Use 'session-manager list-apps' to see available apps."
                exit 1
            fi

            # Expand tilde in path
            work_dir="${work_dir/#\~/$HOME}"

            # Validate directory exists
            if [ ! -d "$work_dir" ]; then
                print_error "Directory does not exist: $work_dir"
                exit 1
            fi

            # Generate session name if not provided
            if [ -z "$session_name" ]; then
                session_name="$app-$(date +%H%M)"
            else
                session_name="$app-$session_name"
            fi

            # Check if session exists - attach if so, create if not
            if tmux has-session -t "$session_name" 2>/dev/null; then
                print_info "Session '$session_name' already exists, attaching..."
                attach_session "$session_name"
            else
                create_session "$app" "$session_name" "$work_dir"
                if [ "$detach" = false ]; then
                    attach_session "$session_name"
                fi
            fi
            exit 0
            ;;
    esac
}

main "$@"
